<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Empire - Admin</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <h1>Empire Game - Admin</h1>
      <h2>Manage Names</h2>

      <div id="message" class="message"></div>

      <div
        style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap"
      >
        <button id="randomizeBtn" class="randomize-btn">Randomize</button>
        <button id="showHideBtn" class="reveal-btn" style="display: none">
          Show Names
        </button>
        <button id="deleteAllBtn" class="delete-all-btn">
          Delete All Names
        </button>
      </div>

      <div class="names-list">
        <h3>All Names</h3>
        <div id="namesContainer" style="display: none">
          <p class="empty">No names yet</p>
        </div>
        <div id="hiddenMessage" class="hidden-message">
          Names are hidden. Click "Randomize" to randomize, then "Show Names" to view them.
        </div>
      </div>
    </div>

    <script>
      const messageDiv = document.getElementById("message");
      const namesContainer = document.getElementById("namesContainer");
      const hiddenMessage = document.getElementById("hiddenMessage");
      const deleteAllBtn = document.getElementById("deleteAllBtn");
      const randomizeBtn = document.getElementById("randomizeBtn");
      const showHideBtn = document.getElementById("showHideBtn");

      let shuffledNames = [];
      let isShuffled = false;
      let isVisible = false;

      // Load names on page load
      loadNames();

      // Handle buttons
      deleteAllBtn.addEventListener("click", deleteAllNames);
      randomizeBtn.addEventListener("click", randomizeNames);
      showHideBtn.addEventListener("click", toggleShowHide);

      // Load all names and preserve shuffled state
      async function loadNames() {
        try {
          const response = await fetch("/api/names");
          const currentNames = await response.json();

          if (currentNames.length === 0) {
            shuffledNames = [];
            isShuffled = false;
            isVisible = false;
            namesContainer.innerHTML = '<p class="empty">No names yet</p>';
            namesContainer.style.display = "block";
            hiddenMessage.style.display = "none";
            showHideBtn.style.display = "none";
            return;
          }

          // If we have shuffled names, update them with any new names
          if (isShuffled && shuffledNames.length > 0) {
            // Find new names that weren't in shuffledNames
            const existingIds = new Set(shuffledNames.map((n) => n.id));
            const newNames = currentNames.filter((n) => !existingIds.has(n.id));
            
            // Remove names that were deleted
            const currentIds = new Set(currentNames.map((n) => n.id));
            shuffledNames = shuffledNames.filter((n) => currentIds.has(n.id));

            // Add new names at random positions
            newNames.forEach((newName) => {
              const randomIndex = Math.floor(Math.random() * (shuffledNames.length + 1));
              shuffledNames.splice(randomIndex, 0, newName);
            });

            // Update names that might have been edited
            shuffledNames = shuffledNames.map((shuffled) => {
              const current = currentNames.find((n) => n.id === shuffled.id);
              return current || shuffled;
            });

            // Show/hide based on current state
            if (isVisible) {
              displayNames(shuffledNames);
            } else {
              updateHiddenMessage(shuffledNames.length);
            }
          } else {
            // Not shuffled yet, just show regular order or hide
            if (!isVisible) {
              updateHiddenMessage(currentNames.length);
            } else {
              displayNames(currentNames);
            }
          }

          // Show the show/hide button if we have names
          if (currentNames.length > 0) {
            showHideBtn.style.display = "block";
          }
        } catch (error) {
          console.error("Error loading names:", error);
          showMessage("Error loading names", "error");
        }
      }

      // Randomize names and keep the shuffled order
      async function randomizeNames() {
        try {
          const response = await fetch("/api/names");
          const names = await response.json();

          if (names.length === 0) {
            showMessage("No names to randomize", "error");
            return;
          }

          // Shuffle the names array
          shuffledNames = [...names];
          for (let i = shuffledNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledNames[i], shuffledNames[j]] = [
              shuffledNames[j],
              shuffledNames[i],
            ];
          }

          isShuffled = true;
          isVisible = false;

          // Update display
          hideNames();
          showHideBtn.style.display = "block";
          showHideBtn.textContent = "Show Names";
          showMessage(
            `Randomized ${names.length} name${names.length !== 1 ? "s" : ""}.`,
            "success"
          );
        } catch (error) {
          console.error("Error randomizing names:", error);
          showMessage("Error randomizing names", "error");
        }
      }

      // Toggle show/hide
      async function toggleShowHide() {
        if (!isShuffled) {
          // Not shuffled yet, fetch current names and toggle
          try {
            const response = await fetch("/api/names");
            const names = await response.json();
            
            if (names.length === 0) {
              showMessage("No names to show", "error");
              return;
            }
            
            if (isVisible) {
              hideNames();
              showHideBtn.textContent = "Show Names";
            } else {
              isVisible = true;
              displayNames(names);
              showHideBtn.textContent = "Hide Names";
            }
          } catch (error) {
            showMessage("Error loading names", "error");
          }
        } else {
          // Use shuffled order
          if (isVisible) {
            hideNames();
            showHideBtn.textContent = "Show Names";
          } else {
            showNames();
            showHideBtn.textContent = "Hide Names";
          }
        }
      }

      // Show the names
      function showNames() {
        if (shuffledNames.length === 0) {
          showMessage("No names to show", "error");
          return;
        }
        isVisible = true;
        displayNames(shuffledNames);
      }

      // Hide the names
      async function hideNames() {
        isVisible = false;
        namesContainer.style.display = "none";
        hiddenMessage.style.display = "block";
        
        if (isShuffled && shuffledNames.length > 0) {
          updateHiddenMessage(shuffledNames.length);
        } else {
          // Get current count for non-shuffled
          try {
            const response = await fetch("/api/names");
            const names = await response.json();
            updateHiddenMessage(names.length);
          } catch (error) {
            updateHiddenMessage(0);
          }
        }
      }

      // Update hidden message with count
      function updateHiddenMessage(count) {
        if (count === 0) {
          hiddenMessage.textContent = "No names yet";
        } else if (isShuffled) {
          hiddenMessage.textContent = `${count} name${
            count !== 1 ? "s" : ""
          } hidden (randomized). Click "Show Names" to view them.`;
        } else {
          hiddenMessage.textContent = `${count} name${
            count !== 1 ? "s" : ""
          } hidden. Click "Randomize" to randomize, then "Show Names" to view them.`;
        }
      }

      // Display names with edit/delete options
      function displayNames(names) {
        if (names.length === 0) {
          namesContainer.innerHTML = '<p class="empty">No names yet</p>';
          namesContainer.style.display = "block";
          hiddenMessage.style.display = "none";
          return;
        }

        namesContainer.innerHTML = names
          .map(
            (name) => `
                <div class="name-item-admin">
                    <input 
                        type="text" 
                        value="${escapeHtml(name.name)}" 
                        class="name-input" 
                        data-id="${name.id}"
                        onchange="updateName('${name.id}', this.value)"
                    >
                    <button 
                        class="delete-btn" 
                        onclick="deleteName('${name.id}')"
                    >
                        Delete
                    </button>
                </div>
            `
          )
          .join("");
        namesContainer.style.display = "block";
        hiddenMessage.style.display = "none";
      }

      // Update name
      async function updateName(id, newName) {
        const name = newName.trim();
        if (!name) {
          showMessage("Name cannot be empty", "error");
          loadNames(); // Reload to reset
          return;
        }

        try {
          const response = await fetch(`/api/names/${id}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ name }),
          });

          if (response.ok) {
            showMessage("Name updated successfully!", "success");
            loadNames(); // Reload to update display
          } else {
            const error = await response.json();
            showMessage(error.error || "Failed to update name", "error");
            loadNames(); // Reload to reset
          }
        } catch (error) {
          showMessage("Error updating name", "error");
          loadNames(); // Reload to reset
        }
      }

      // Delete name (no confirmation) - must be global for onclick
      window.deleteName = async function (id) {
        try {
          const response = await fetch(`/api/names/${id}`, {
            method: "DELETE",
          });

          if (response.ok) {
            showMessage("Name deleted successfully!", "success");
            // Remove from shuffledNames if shuffled
            if (isShuffled) {
              shuffledNames = shuffledNames.filter((n) => n.id !== id);
            }
            loadNames();
          } else {
            const error = await response.json();
            showMessage(error.error || "Failed to delete name", "error");
          }
        } catch (error) {
          showMessage("Error deleting name", "error");
        }
      };

      // Delete all names (with confirmation)
      async function deleteAllNames() {
        if (
          !confirm(
            "Are you sure you want to delete ALL names? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          const response = await fetch("/api/names", {
            method: "DELETE",
          });

          if (response.ok) {
            shuffledNames = [];
            isShuffled = false;
            isVisible = false;
            showMessage("All names deleted successfully!", "success");
            loadNames();
          } else {
            const error = await response.json();
            showMessage(error.error || "Failed to delete all names", "error");
          }
        } catch (error) {
          showMessage("Error deleting all names", "error");
        }
      }

      // Show message
      function showMessage(text, type) {
        messageDiv.textContent = text;
        messageDiv.className = `message ${type}`;
        setTimeout(() => {
          messageDiv.textContent = "";
          messageDiv.className = "message";
        }, 3000);
      }

      // Escape HTML to prevent XSS
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }
    </script>
  </body>
</html>
