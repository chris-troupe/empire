<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Empire - Admin</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <h1>Empire Game - Admin</h1>
      <h2>Manage Names</h2>

      <div id="message" class="message"></div>

      <div
        style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap"
      >
        <button id="randomizeBtn" class="randomize-btn">
          Randomize & Hide
        </button>
        <button id="revealBtn" class="reveal-btn" style="display: none">
          Reveal Names
        </button>
        <button id="deleteAllBtn" class="delete-all-btn">
          Delete All Names
        </button>
      </div>

      <div class="names-list">
        <h3>All Names</h3>
        <div id="namesContainer" style="display: none">
          <p class="empty">
            Click "Randomize & Hide" to prepare, then "Reveal Names" to see them
          </p>
        </div>
        <div id="hiddenMessage" class="hidden-message">
          Names are hidden. Click "Randomize & Hide" to prepare, then "Reveal
          Names" to see them.
        </div>
      </div>
    </div>

    <script>
      const messageDiv = document.getElementById("message");
      const namesContainer = document.getElementById("namesContainer");
      const hiddenMessage = document.getElementById("hiddenMessage");
      const deleteAllBtn = document.getElementById("deleteAllBtn");
      const randomizeBtn = document.getElementById("randomizeBtn");
      const revealBtn = document.getElementById("revealBtn");

      let shuffledNames = [];
      let isRevealed = false;

      // Load names on page load
      loadNames();

      // Handle buttons
      deleteAllBtn.addEventListener("click", deleteAllNames);
      randomizeBtn.addEventListener("click", randomizeAndHide);
      revealBtn.addEventListener("click", revealNames);

      // Load all names
      async function loadNames() {
        try {
          const response = await fetch("/api/names");
          const names = await response.json();

          // If names changed while hidden, hide again
          if (!isRevealed) {
            hideNames();
            updateHiddenMessage(names.length);
          } else {
            displayNames(names);
          }
        } catch (error) {
          console.error("Error loading names:", error);
          showMessage("Error loading names", "error");
        }
      }

      // Randomize and hide names
      function randomizeAndHide() {
        async function doRandomize() {
          try {
            const response = await fetch("/api/names");
            const names = await response.json();

            if (names.length === 0) {
              showMessage("No names to randomize", "error");
              return;
            }

            // Shuffle the names array
            shuffledNames = [...names];
            for (let i = shuffledNames.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [shuffledNames[i], shuffledNames[j]] = [
                shuffledNames[j],
                shuffledNames[i],
              ];
            }

            // Hide the names
            hideNames();
            revealBtn.style.display = "block";
            showMessage(
              `Randomized ${names.length} names. Click "Reveal Names" to see them.`,
              "success"
            );
          } catch (error) {
            console.error("Error randomizing names:", error);
            showMessage("Error randomizing names", "error");
          }
        }
        doRandomize();
      }

      // Reveal the shuffled names
      function revealNames() {
        if (shuffledNames.length === 0) {
          showMessage(
            "No names to reveal. Click 'Randomize & Hide' first.",
            "error"
          );
          return;
        }

        isRevealed = true;
        displayNames(shuffledNames);
        hiddenMessage.style.display = "none";
        namesContainer.style.display = "block";
        revealBtn.style.display = "none";
      }

      // Hide the names
      function hideNames() {
        isRevealed = false;
        namesContainer.style.display = "none";
        hiddenMessage.style.display = "block";
      }

      // Update hidden message with count
      function updateHiddenMessage(count) {
        if (count === 0) {
          hiddenMessage.textContent = "No names yet";
        } else {
          hiddenMessage.textContent = `${count} name${
            count !== 1 ? "s" : ""
          } hidden. Click "Randomize & Hide" to prepare, then "Reveal Names" to see them.`;
        }
      }

      // Display names with edit/delete options
      function displayNames(names) {
        if (names.length === 0) {
          namesContainer.innerHTML = '<p class="empty">No names yet</p>';
          namesContainer.style.display = "block";
          hiddenMessage.style.display = "none";
          return;
        }

        namesContainer.innerHTML = names
          .map(
            (name) => `
                <div class="name-item-admin">
                    <input 
                        type="text" 
                        value="${escapeHtml(name.name)}" 
                        class="name-input" 
                        data-id="${name.id}"
                        onchange="updateName('${name.id}', this.value)"
                    >
                    <button 
                        class="delete-btn" 
                        onclick="deleteName('${name.id}')"
                    >
                        Delete
                    </button>
                </div>
            `
          )
          .join("");
        namesContainer.style.display = "block";
        hiddenMessage.style.display = "none";
      }

      // Update name
      async function updateName(id, newName) {
        const name = newName.trim();
        if (!name) {
          showMessage("Name cannot be empty", "error");
          loadNames(); // Reload to reset
          return;
        }

        try {
          const response = await fetch(`/api/names/${id}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ name }),
          });

          if (response.ok) {
            showMessage("Name updated successfully!", "success");
          } else {
            const error = await response.json();
            showMessage(error.error || "Failed to update name", "error");
            loadNames(); // Reload to reset
          }
        } catch (error) {
          showMessage("Error updating name", "error");
          loadNames(); // Reload to reset
        }
      }

      // Delete name (no confirmation) - must be global for onclick
      window.deleteName = async function (id) {
        try {
          const response = await fetch(`/api/names/${id}`, {
            method: "DELETE",
          });

          if (response.ok) {
            showMessage("Name deleted successfully!", "success");
            // If revealed, update the displayed names
            if (isRevealed) {
              // Remove from shuffledNames if it exists there
              shuffledNames = shuffledNames.filter((n) => n.id !== id);
              // Reload names
              const namesResponse = await fetch("/api/names");
              const names = await namesResponse.json();
              if (names.length === 0) {
                hideNames();
                shuffledNames = [];
              } else {
                displayNames(
                  shuffledNames.filter((n) =>
                    names.some((name) => name.id === n.id)
                  )
                );
              }
            } else {
              loadNames();
            }
          } else {
            const error = await response.json();
            showMessage(error.error || "Failed to delete name", "error");
          }
        } catch (error) {
          showMessage("Error deleting name", "error");
        }
      };

      // Delete all names (with confirmation)
      async function deleteAllNames() {
        if (
          !confirm(
            "Are you sure you want to delete ALL names? This action cannot be undone."
          )
        ) {
          return;
        }

        try {
          const response = await fetch("/api/names", {
            method: "DELETE",
          });

          if (response.ok) {
            shuffledNames = [];
            isRevealed = false;
            showMessage("All names deleted successfully!", "success");
            loadNames();
          } else {
            const error = await response.json();
            showMessage(error.error || "Failed to delete all names", "error");
          }
        } catch (error) {
          showMessage("Error deleting all names", "error");
        }
      }

      // Show message
      function showMessage(text, type) {
        messageDiv.textContent = text;
        messageDiv.className = `message ${type}`;
        setTimeout(() => {
          messageDiv.textContent = "";
          messageDiv.className = "message";
        }, 3000);
      }

      // Escape HTML to prevent XSS
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Refresh names every 5 seconds only if revealed
      setInterval(() => {
        if (isRevealed) {
          loadNames();
        }
      }, 5000);
    </script>
  </body>
</html>
